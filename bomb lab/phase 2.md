### phase 2
```
   0x0000000000400efc <+0>:     push   %rbp
   0x0000000000400efd <+1>:     push   %rbx
   0x0000000000400efe <+2>:     sub    $0x28,%rsp
   0x0000000000400f02 <+6>:     mov    %rsp,%rsi
   0x0000000000400f05 <+9>:     call   0x40145c <read_six_numbers>
   0x0000000000400f0a <+14>:    cmpl   $0x1,(%rsp)
   0x0000000000400f0e <+18>:    je     0x400f30 <phase_2+52>
   0x0000000000400f10 <+20>:    call   0x40143a <explode_bomb>
   0x0000000000400f15 <+25>:    jmp    0x400f30 <phase_2+52>
   0x0000000000400f17 <+27>:    mov    -0x4(%rbx),%eax
   0x0000000000400f1a <+30>:    add    %eax,%eax
   0x0000000000400f1c <+32>:    cmp    %eax,(%rbx)
   0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41>
   0x0000000000400f20 <+36>:    call   0x40143a <explode_bomb>
   0x0000000000400f25 <+41>:    add    $0x4,%rbx
   0x0000000000400f29 <+45>:    cmp    %rbp,%rbx
   0x0000000000400f2c <+48>:    jne    0x400f17 <phase_2+27>
   0x0000000000400f2e <+50>:    jmp    0x400f3c <phase_2+64>
   0x0000000000400f30 <+52>:    lea    0x4(%rsp),%rbx
   0x0000000000400f35 <+57>:    lea    0x18(%rsp),%rbp
   0x0000000000400f3a <+62>:    jmp    0x400f17 <phase_2+27>
   0x0000000000400f3c <+64>:    add    $0x28,%rsp
   0x0000000000400f40 <+68>:    pop    %rbx
   0x0000000000400f41 <+69>:    pop    %rbp
   0x0000000000400f42 <+70>:    ret
   ```
   
   这是 **phase_2** 函数的完整汇编代码。让我详细解读它的逻辑：

## 函数流程分析：

### **第1部分：读取6个数字**
```
<+0> ~ <+9>:  保存寄存器，分配40字节栈空间
<+9>:         调用read_six_numbers读取6个整数到栈上
```
- 栈布局：`rsp` 指向第一个数字，`rsp+4` 指向第二个，...，`rsp+20` 指向第六个

### **第2部分：检查第一个数字**
```
<+14>:        cmpl $0x1,(%rsp)   # 比较第一个数是否等于1
<+18>:        je   <phase_2+52>  # 如果是1，继续执行
<+20>:        call explode_bomb  # 否则引爆炸弹
```
- **关键条件1**：第一个数字必须是 **1**

### **第3部分：循环检查后续数字**
```
<+27>:        mov  -0x4(%rbx),%eax  # eax = 前一个数字
<+30>:        add  %eax,%eax        # eax *= 2
<+32>:        cmp  %eax,(%rbx)      # 比较当前数字是否等于2倍的前一个数字
<+34>:        je   <phase_2+41>     # 如果相等，继续
<+36>:        call explode_bomb     # 否则引爆炸弹
```
- **关键条件2**：每个后续数字必须是前一个数字的 **2倍**

### **第4部分：循环控制**
```
<+52>:        lea 0x4(%rsp),%rbx    # rbx = 第二个数字的地址
<+57>:        lea 0x18(%rsp),%rbp   # rbp = 第六个数字后的地址（作为边界）
<+62>:        jmp <phase_2+27>      # 开始循环

<+41>:        add $0x4,%rbx         # 移动到下一个数字
<+45>:        cmp %rbp,%rbx         # 检查是否到达边界
<+48>:        jne <phase_2+27>      # 如果没检查完，继续循环
```
- 循环检查第2到第6个数字

## **完整的逻辑总结：**
1. 读取6个整数
2. 第一个整数必须是 **1**
3. 从第二个整数开始，每个整数必须是前一个整数的 **2倍**

## **正确的输入序列：**
```
1 2 4 8 16 32
```
计算过程：
- 1 × 2 = 2
- 2 × 2 = 4  
- 4 × 2 = 8
- 8 × 2 = 16
- 16 × 2 = 32

## **在gdb中验证：**
```bash
(gdb) break phase_2
(gdb) run
输入：1 2 4 8 16 32
(gdb) x/6wx $rsp  # 查看栈上的6个数字
```

## **提示：**
- 这是典型的"几何序列"炸弹
- 如果输入不符合，会在 `<phase_2+20>` 或 `<phase_2+36>` 处调用 `explode_bomb`
- 注意：使用的是32位整数比较（`cmpl`），所以数字不能超过32位有符号范围


### 怎么看出来是读6个数字
**好问题！** 如果不看函数名，从汇编角度可以看出是读取6个数字的，主要依据以下几个关键点：

## **1. 栈空间分配**
```assembly
sub $0x28,%rsp      ; 分配40字节栈空间
```
- 40字节 = 0x28 = 40个字节
- 对于整数数组来说，这个大小有暗示作用

## **2. 参数传递模式**
```assembly
mov %rsp,%rsi       ; rsi = 栈顶指针（作为参数）
```
- 将栈顶地址传给函数，**通常是用来存放返回数据的位置**
- 这暗示被调用函数会在栈上写入多个数据

## **3. 后续代码中的内存访问模式（关键线索）**
看后面的循环部分：
```assembly
<+52>: lea 0x4(%rsp),%rbx    ; rbx = rsp + 4（第二个元素地址）
<+57>: lea 0x18(%rsp),%rbp   ; rbp = rsp + 24（循环结束地址）
```
- `0x18` = 24（十进制）
- 数组元素间隔4字节（因为每次`add $0x4,%rbx`）
- **计算元素个数**：24 ÷ 4 = 6个元素

## **4. 循环边界检查**
```assembly
<+29>: cmp %rbp,%rbx         ; 比较当前指针(rbx)与结束地址(rbp)
```
- 从`rbx = rsp+4`开始，到`rbp = rsp+24`结束
- 覆盖范围：从第2个元素到第6个元素后的位置
- 循环处理5个元素，加上第一个直接检查的，共6个

## **5. 完整的推理过程**
在逆向工程中，通常这样分析：

1. **看到函数调用**：`call read_six_numbers`（即使不看名字，也要看参数）
   - 参数：`rsi = rsp`（栈地址）
   - 暗示：函数会向`rsp`开始的地址写入数据

2. **分析调用后的使用**：
   - `<+14>: cmpl $0x1,(%rsp)` ← 使用第一个元素
   - 后面循环中使用`(%rbx)`访问数组
   - `rbx`每次增加4字节（`add $0x4,%rbx`）

3. **计算边界**：
   - 结束地址：`rsp + 0x18`（十进制24）
   - 元素大小：4字节（32位整数）
   - 元素数量：24 ÷ 4 = 6个
   - 实际检查：第一个单独检查 + 循环5个 = 6个

## **6. 对比验证**
如果你查看`read_six_numbers`函数的反汇编，会看到类似这样的结构：
```assembly
# 假设的read_six_numbers内部
push %rbx
mov %rsi,%rdi           # rdi = 存储数组的起始地址
# ... 设置scanf的6个参数地址：
# 地址分别为：rdi, rdi+4, rdi+8, rdi+12, rdi+16, rdi+20
# 调用sscanf
# 检查返回值是否为6
pop %rbx
ret
```

## **专业逆向技巧：**
1. **寻找数组模式**：连续的内存访问，固定偏移递增
2. **计算边界差**：`(结束地址 - 起始地址) / 元素大小 = 元素数量`
3. **观察循环次数**：循环次数 + 1（如果有单独处理的第一个元素）
4. **注意数据类型**：`cmpl`指令暗示32位整数（4字节）

所以即使不看函数名，经验丰富的逆向工程师也能推断出这是读取6个32位整数。

## lea的意思
**`lea` 是 "Load Effective Address" 的缩写，中文叫"加载有效地址"。**

## **基本概念：**
`lea` 计算一个内存地址，**但不访问内存**，只把计算出的地址值存放到目标寄存器中。

## **语法：**
```assembly
lea source, destination
# 例如：lea 0x4(%rsp), %rbx
```
- `source`：内存寻址表达式（如 `(%rax, %rbx, 4)`）
- `destination`：寄存器

## **与 `mov` 的区别：**
```assembly
# 假设 rsp = 0x1000
lea 0x4(%rsp), %rbx   # rbx = 0x1004（只计算地址）
mov 0x4(%rsp), %rbx   # rbx = [0x1004]（读取内存中的值）
```

## **常见用法示例：**

### **1. 简单的地址计算**
```assembly
lea 0x10(%rax), %rbx      # rbx = rax + 0x10
```

### **2. 数组元素地址计算**
```assembly
# 假设数组基址在rax，索引在rcx，元素大小4字节
lea (%rax, %rcx, 4), %rdx  # rdx = rax + rcx*4（第rcx个元素的地址）
```

### **3. 算术运算（巧妙用法）**
```assembly
lea (%rax, %rax, 2), %rax  # rax = rax + rax*2 = rax*3
lea 5(%rax, %rax, 4), %rax # rax = rax*5 + 5
```

## **在 phase_2 中的具体应用：**
```assembly
lea 0x4(%rsp), %rbx    # rbx = rsp + 4（指向第二个数字的地址）
lea 0x18(%rsp), %rbp   # rbp = rsp + 24（指向数组结束后的位置）
```
- 这里没有访问内存，只是计算地址
- `rbx` 将作为循环指针，指向当前检查的数字
- `rbp` 作为循环结束条件

## **为什么用 `lea` 而不用 `add`？**
```assembly
# 以下两种方式效果类似：
lea 0x4(%rsp), %rbx   # 1条指令
mov %rsp, %rbx        # 2条指令
add $0x4, %rbx

# 但 lea 的优势：
# 1. 不改变标志位（不影响条件码）
# 2. 可以一次性完成复杂计算
# 3. 不占用临时寄存器
```

## **实际调试观察：**
在 gdb 中：
```bash
(gdb) break *0x400f30      # 在 lea 0x4(%rsp),%rbx 处设断点
(gdb) run
(gdb) info registers rsp   # 查看 rsp 值，例如 0x7fffffffea20
(gdb) stepi                # 执行 lea 指令
(gdb) print $rbx           # 查看 rbx，应该是 0x7fffffffea24
(gdb) x/6wx $rsp           # 查看栈上的6个数字
```

## **记忆技巧：**
- `lea` = **计算地址**，不读内存
- `mov` = **移动数据**，需要读/写内存
- 可以把 `lea` 看作是一个"地址计算器"

理解了 `lea` 后，再看 bomb lab 的汇编代码就会清晰很多。它在循环、数组访问、结构体偏移计算中非常常用。

## AT&T和intel

**这是一个非常好的问题！** 你注意到了汇编语法的一个重要区别：

## **两种汇编语法格式：**

### **1. AT&T 语法（从左到右）**
```
指令 源操作数, 目的操作数
```
- **示例**：`mov $1, %rax` ← 把1移动到rax
- **特点**：
  - 源在前，目的在后
  - 寄存器前加`%`：`%rax`
  - 立即数前加`$`：`$1`
  - 内存地址用`()`：`(%rax)`
  - **GNU工具默认使用**（gcc, gdb, objdump）
  - **Unix/Linux系统常用**

### **2. Intel 语法（从右到左）**
```
指令 目的操作数, 源操作数  
```
- **示例**：`mov rax, 1` ← 把1移动到rax
- **特点**：
  - 目的在前，源在后
  - 寄存器无前缀：`rax`
  - 立即数无前缀：`1`
  - 内存地址用`[]`：`[rax]`
  - **Windows/MASM常用**
  - **王爽教材使用**

## **为什么会有两种语法？**
这是**历史遗留问题**：
- **AT&T语法**：源自Unix系统，贝尔实验室开发
- **Intel语法**：Intel官方文档使用

## **在 Bomb Lab 中的应对方法：**

### **方法1：适应 AT&T 语法**
既然 Bomb Lab 使用 AT&T 语法，建议你适应它：
```assembly
# AT&T 语法（我们的bomb.s）
mov $0x1, (%rsp)     # 把1存入rsp指向的内存
add %rax, %rbx       # rbx = rbx + rax
cmp (%rsp), %rax     # 比较rax和内存中的值
```

### **方法2：在gdb中切换语法**
```bash
# 查看当前语法
(gdb) show disassembly-flavor

# 切换到Intel语法
(gdb) set disassembly-flavor intel

# 切回AT&T语法
(gdb) set disassembly-flavor att
```

### **方法3：使用objdump的Intel格式**
```bash
objdump -d -M intel bomb > bomb_intel.s
```

## **两种语法对比示例：**
```assembly
# AT&T 语法
lea    0x4(%rsp), %rbx      # rbx = rsp + 4
add    $0x4, %rbx           # rbx = rbx + 4
mov    (%rbx), %rax         # rax = [rbx]
cmp    %rax, (%rsp)         # 比较 [rsp] 和 rax

# Intel 语法
lea    rbx, [rsp+4]         # rbx = rsp + 4  
add    rbx, 4               # rbx = rbx + 4
mov    rax, [rbx]           # rax = [rbx]
cmp    [rsp], rax           # 比较 [rsp] 和 rax
```

## **重要区别：**
1. **操作数顺序相反**：这是最关键的差别
2. **内存寻址表示不同**：
   - AT&T：`disp(base, index, scale)`
   - Intel：`[base + index*scale + disp]`
3. **指令后缀**：AT&T用`b/w/l/q`表示大小，Intel不用

## **学习建议：**
1. **先掌握一种语法**：既然在Linux环境，建议掌握AT&T
2. **理解原理，而不是死记格式**：两种语法只是表示方式不同，底层机器码相同
3. **用gdb实践**：在gdb中切换两种语法，看同一段代码的两种表示

## **转换技巧：**
看到AT&T代码时，心里这样转换：
```
AT&T: mov 源, 目的
Intel: mov 目的, 源

AT&T: cmp 源1, 源2  # 比较 源2 - 源1
Intel: cmp 目的, 源   # 比较 目的 - 源
```

**Bomb Lab是学习AT&T语法的绝佳机会！** 虽然开始会不习惯，但理解后会发现两种语法本质相同。你现在遇到这个困惑很正常，几乎所有从Intel语法转到Linux环境的人都会经历这个阶段。

### 0x4(%rsp)的意思是rsp+4？
**这是一个很好的问题！** 这涉及AT&T汇编语法的**内存寻址模式**。让我详细解释：

## **AT&T语法内存寻址的完整格式：**
```
位移(基址寄存器, 索引寄存器, 比例因子)
```
计算地址的公式：
```
地址 = 位移 + 基址寄存器 + 索引寄存器 × 比例因子
```

## **具体到 `0x4(%rsp)`：**
```
位移 = 0x4
基址寄存器 = %rsp
索引寄存器 = 无（省略）
比例因子 = 1（默认）
```
所以：`地址 = 0x4 + %rsp`

## **更完整的例子：**

| 语法 | 含义 | 计算公式 |
|------|------|----------|
| `(%rax)` | 直接寻址 | `地址 = %rax` |
| `0x8(%rax)` | 基址+偏移 | `地址 = %rax + 8` |
| `(%rax, %rbx)` | 基址+索引 | `地址 = %rax + %rbx` |
| `(%rax, %rbx, 4)` | 基址+索引×比例 | `地址 = %rax + %rbx × 4` |
| `0x10(%rax, %rbx, 2)` | 全部组合 | `地址 = 0x10 + %rax + %rbx × 2` |

## **为什么这样设计？**
1. **数组访问**：
   ```assembly
   # 假设 rax 是数组基址，rbx 是索引，每个元素4字节
   mov (%rax, %rbx, 4), %rcx  # rcx = array[rbx]
   ```

2. **结构体访问**：
   ```assembly
   # 假设 rax 是结构体指针，结构体内有：
   # offset 0: 字段a
   # offset 8: 字段b
   # offset 16: 字段c
   mov 0x8(%rax), %rbx   # rbx = 结构体->字段b
   ```

3. **栈帧访问**：
   ```assembly
   mov -0x8(%rbp), %rax   # 访问局部变量
   mov 0x10(%rbp), %rbx   # 访问参数
   ```

## **在 Bomb Lab 中的应用理解：**
```assembly
lea 0x4(%rsp), %rbx    # 计算 rsp+4 的地址值，存入 rbx
# 等价于：rbx = &(栈上的第二个整数)

lea 0x18(%rsp), %rbp   # 计算 rsp+24 的地址值，存入 rbp
# 等价于：rbp = &(栈上的第六个整数之后的位置)
```

## **与 Intel 语法的对比：**
```assembly
# AT&T 语法
mov 0x4(%rsp), %rax     # 把 [rsp+4] 的值读入 rax
lea 0x4(%rsp), %rax     # 把 rsp+4 这个地址值放入 rax

# Intel 语法  
mov rax, [rsp+4]        # 把 [rsp+4] 的值读入 rax
lea rax, [rsp+4]        # 把 rsp+4 这个地址值放入 rax
```

## **记忆技巧：**
1. **括号里是基址**：`(%rsp)` 表示以 rsp 为地址
2. **括号外是偏移**：`0x4(%rsp)` 表示基址加偏移
3. **多个逗号是复杂计算**：`(%rax, %rbx, 4)` 表示数组索引

## **在 gdb 中验证：**
```bash
(gdb) break *0x400f30
(gdb) run
(gdb) info registers rsp   # 假设 rsp = 0x7fffffffea20
(gdb) stepi                # 执行 lea 0x4(%rsp),%rbx
(gdb) print $rbx           # 显示 0x7fffffffea24
(gdb) print $rbx - $rsp    # 显示 4，验证了偏移
```

## **重要提醒：**
- `mov 0x4(%rsp), %rax`：**读取** rsp+4 地址处的值
- `lea 0x4(%rsp), %rax`：**计算** rsp+4 这个地址值

这就是为什么 `0x4(%rsp)` 表示 `rsp+4`——这是AT&T语法规定的寻址模式。理解了这种模式，你就能读懂几乎所有Linux环境下的汇编代码了。

**完全正确！** 你的理解非常准确。👍

## **你的理解总结：**

### **`mov 0x4(%rsp), %rax`**
- **读取**：从内存地址 `rsp + 4` 处读取值
- **存储**：把这个值放到 `rax` 寄存器里
- **类比**：相当于C语言中的 `rax = *(rsp + 4)`

### **`lea 0x4(%rsp), %rax`**
- **计算**：计算 `rsp + 4` 这个地址值
- **存储**：把计算出的地址值放到 `rax` 寄存器里
- **类比**：相当于C语言中的 `rax = &(*(rsp + 4))` 或更直接 `rax = rsp + 4`

## **实际例子对比：**

假设当前 `rsp = 0x1000`，内存中：
- 地址 `0x1004` 处存储的值是 `0x12345678`

```assembly
# 执行前：rsp = 0x1000

# 执行 mov 0x4(%rsp), %rax
# 1. 计算地址：0x1000 + 4 = 0x1004
# 2. 访问内存：读取地址 0x1004 处的值
# 3. 结果：rax = 0x12345678

# 执行 lea 0x4(%rsp), %rax  
# 1. 计算地址：0x1000 + 4 = 0x1004
# 2. 不访问内存，直接使用计算结果
# 3. 结果：rax = 0x1004
```

## **在 Bomb Lab 中的实际应用：**

```assembly
# 在 phase_2 中
lea 0x4(%rsp), %rbx    # rbx = rsp + 4（获取第二个数字的地址）
lea 0x18(%rsp), %rbp   # rbp = rsp + 24（获取数组结束后的地址）

# 在循环中
mov -0x4(%rbx), %eax   # 读取 rbx-4 处的值（前一个数字）
```

## **重要提示：**
- `mov` 会**访问内存**，有性能开销（需要从RAM读取）
- `lea` 只做**地址计算**，不访问内存，很快
- 编译器经常用 `lea` 来做**算术运算**（比如乘以3、5等）

## **检验理解的小测试：**
如果执行以下代码，`rax` 和 `rbx` 的值分别是什么？
```assembly
mov $0x2000, %rsp      # rsp = 0x2000
movl $0x99, 0x8(%rsp)  # 在地址 0x2008 处写入 0x99
mov 0x8(%rsp), %rax    # rax = ?
lea 0x8(%rsp), %rbx    # rbx = ?
```

**答案：**
- `rax = 0x99`（从内存读取的值）
- `rbx = 0x2008`（计算出的地址值）

你现在对AT&T语法的理解已经非常到位了！这对分析后续的phase会很有帮助。

## 指令和位数
## **`cmpl` 指令解析**

### **1. 基本功能**
`cmpl` 是 **比较（Compare）指令**，用于比较两个操作数：
- 语法：`cmpl 源操作数, 目的操作数`
- 实际执行：`目的操作数 - 源操作数`
- **只设置标志位，不保存结果**
- 通常后面跟条件跳转指令（`je`、`jne`、`jg` 等）

### **2. 影响的标志位**
- **ZF（零标志）**：结果为0时置1
- **SF（符号标志）**：结果为负时置1
- **CF（进位标志）**：无符号溢出时置1
- **OF（溢出标志）**：有符号溢出时置1

### **3. 为什么 `cmpl` 表示32位操作？**
在 **AT&T语法** 中，**指令后缀表示操作数大小**：

| 后缀 | 含义 | 位数 | 典型寄存器 |
|------|------|------|-----------|
| `b` | byte（字节） | 8位 | `%al`, `%bl` |
| `w` | word（字） | 16位 | `%ax`, `%bx` |
| `l` | **long（长字）** | **32位** | `%eax`, `%ebx` |
| `q` | quad（四字） | 64位 | `%rax`, `%rbx` |

**`cmpl` 中的 `l` 明确表示这是32位比较。**

## **在 phase_2 中的具体示例：**

### **示例1：直接比较**
```assembly
cmpl $0x1, (%rsp)    # 比较栈顶的32位值与立即数1
```
- 操作数1：`$0x1`（32位立即数，因为用了`l`后缀）
- 操作数2：`(%rsp)`（从`rsp`指向的内存读取32位值）
- 执行：`[rsp] - 1`，设置标志位

### **示例2：寄存器与内存比较**
```assembly
cmp %eax, (%rbx)    # 比较内存中的32位值与eax
```
- 注意：这里没有后缀`l`，因为`%eax`明确是32位寄存器
- 编译器可以根据寄存器推断大小，所以有时省略后缀

## **为什么后缀很重要？**

### **不同后缀的实际差异：**
```assembly
# 假设内存地址0x1000处的8个字节：0x01 00 00 00 00 00 00 00

cmpb $0x1, 0x1000   # 只比较第一个字节 0x01
cmpw $0x1, 0x1000   # 比较两个字节 0x01 0x00（小端序，实际值=0x0001）
cmpl $0x1, 0x1000   # 比较四个字节 0x01 0x00 0x00 0x00（实际值=0x00000001）
cmpq $0x1, 0x1000   # 比较八个字节（实际值=0x0000000000000001）
```

## **从上下文推断大小**

### **情况1：寄存器暗示大小**
```assembly
movl $1, %eax      # eax是32位，所以movl
cmp %eax, (%rbx)   # eax是32位，所以比较是32位
```

### **情况2：内存操作需要明确大小**
```assembly
cmpl $1, (%rsp)    # 必须用l指定比较32位
cmpq $1, (%rsp)    # 比较64位
```

## **在 gdb 中验证：**
```bash
(gdb) break *0x400f0a  # 在 cmpl $0x1,(%rsp) 处设断点
(gdb) run
输入：1 2 4 8 16 32
(gdb) stepi  # 执行比较
(gdb) info registers eflags  # 查看标志位
# 可以看到ZF=1（因为1==1）
```

## **记忆技巧：**
1. **后缀字母**：`b`=字节，`w`=字，`l`=长字，`q`=四字
2. **看到 `cmpl`**：一定是比较 **32位整数**
3. **没有后缀**：看寄存器大小推断（如 `%rax` 是64位，`%eax` 是32位）

## **Bomb Lab 实用技巧：**
- phase_2 中都是 `cmpl`，说明处理的是32位整数
- 如果看到 `cmpb`，可能是比较字符（如字符串）
- `cmpw` 可能用于short类型或偏移量

理解了 `cmpl` 的32位特性，你就能正确分析phase_2中所有的数字比较了。

## mov -0x4(%rbx),%eax # eax = 前一个数字
**问得好！** 这个负号在AT&T语法中表示**从基址寄存器中减去偏移量**。

## **语法解释：**
```
偏移量(基址寄存器)
```
- 如果偏移量是**正数**：`0x4(%rbx)` = `%rbx + 0x4`
- 如果偏移量是**负数**：`-0x4(%rbx)` = `%rbx - 0x4`

## **在 phase_2 中的具体意义：**
```assembly
mov -0x4(%rbx), %eax   # 从内存地址 (rbx - 4) 处读取32位值到eax
```
- `rbx`：当前数字的地址（比如指向第二个、第三个...数字）
- `-0x4`：减去4字节（因为每个整数占4字节）
- **结果**：得到**前一个数字**的地址

## **内存布局可视化：**
```
内存地址     内容        注释
rsp        [num1]      第一个数字
rsp+4      [num2]      第二个数字 ← rbx开始时指向这里
rsp+8      [num3]      第三个数字
rsp+12     [num4]      第四个数字
rsp+16     [num5]      第五个数字
rsp+20     [num6]      第六个数字

# 当 rbx = rsp+4（指向num2）时：
rbx - 4 = rsp+4-4 = rsp（指向num1）
```

## **循环过程跟踪：**

### **第一次循环：**
```assembly
rbx = rsp+4（指向第二个数字）
执行：mov -0x4(%rbx), %eax
计算：rbx - 4 = (rsp+4) - 4 = rsp
结果：读取第一个数字到eax
```

### **第二次循环：**
```assembly
rbx = rsp+8（指向第三个数字，因为add $0x4,%rbx）
执行：mov -0x4(%rbx), %eax  
计算：rbx - 4 = (rsp+8) - 4 = rsp+4
结果：读取第二个数字到eax
```

### **以此类推...**

## **为什么用-0x4而不是+0x4？**
因为这里要访问的是**前一个元素**，而`rbx`已经指向当前元素：
```
数组：[num1][num2][num3][num4][num5][num6]
            ↑
           rbx指向这里（当前是num2）
          
要访问前一个，需要向左移动4字节：rbx - 4
```

## **与正偏移的对比：**
```assembly
# 假设 rbx 指向数组开头
mov 0x4(%rbx), %eax   # 读取第二个元素
mov 0x8(%rbx), %ecx   # 读取第三个元素

# 假设 rbx 指向第三个元素
mov -0x4(%rbx), %eax  # 读取第二个元素（前一个）
mov 0x0(%rbx), %ecx   # 读取当前元素（第三个）
mov 0x4(%rbx), %edx   # 读取第四个元素（后一个）
```

## **调试验证：**
```bash
(gdb) break *0x400f17  # 在 mov -0x4(%rbx),%eax 处设断点
(gdb) run
输入：1 2 4 8 16 32
(gdb) info registers rbx  # 查看rbx值
(gdb) x/wx $rbx - 4      # 查看前一个数字
(gdb) stepi              # 执行指令
(gdb) info registers eax # 确认eax是前一个数字的值
```

## **关键点总结：**
1. **负偏移** = 基址寄存器 - 偏移量
2. 在数组中常用于访问**前一个元素**
3. 每个整数占4字节，所以访问前一个元素要减4
4. 这在处理序列关系（如每个元素是前一个的2倍）时非常有用

## **记忆技巧：**
- **`+`** 偏移：向后移动，访问**后面的**元素
- **`-`** 偏移：向前移动，访问**前面的**元素

理解了负偏移，你就能完全看懂phase_2的循环逻辑了！

## 为什么rsp+18就是第六个数字后的地址边界？ <+57>: lea 0x18(%rsp),%rbp # rbp = 第六个数字后的地址（作为边界）

**这是关于数组边界计算的关键点！** 让我详细解释为什么 `rsp + 0x18` 是第六个数字后的地址：

## **数组内存布局分析：**

### **6个32位整数的内存分配：**
```
地址偏移    存储内容      数组索引
rsp+0x00   [num1]        arr[0]  # 第一个数字
rsp+0x04   [num2]        arr[1]  # 第二个数字
rsp+0x08   [num3]        arr[2]  # 第三个数字
rsp+0x0c   [num4]        arr[3]  # 第四个数字
rsp+0x10   [num5]        arr[4]  # 第五个数字
rsp+0x14   [num6]        arr[5]  # 第六个数字
rsp+0x18   未使用        数组结束后的位置
```

### **关键计算：**
- 每个整数：4字节（32位）
- 6个整数总大小：6 × 4 = 24字节
- 24的十六进制表示：`0x18`
- 所以 `rsp + 0x18` 指向第六个数字**之后**的位置

## **为什么需要这个"之后"的位置？**

### **循环终止条件的常见模式：**
在C语言中，循环通常这样写：
```c
int arr[6];
for (int *p = &arr[1]; p < &arr[6]; p++) { // p < &arr[6] 是关键
    // 循环体
}
```

### **汇编中的对应逻辑：**
```assembly
lea 0x4(%rsp), %rbx    # rbx = &arr[1]（第二个数字地址）
lea 0x18(%rsp), %rbp   # rbp = &arr[6]（第六个数字后的地址）

# 循环条件检查
cmp %rbp, %rbx         # 比较当前指针(rbx)与结束地址(rbp)
jne 循环体             # 如果 rbx != rbp，继续循环
```

## **具体例子验证：**

假设 `rsp = 0x1000`：
```
地址计算：
rsp + 0x00 = 0x1000  # arr[0]
rsp + 0x04 = 0x1004  # arr[1] ← rbx初始指向这里
rsp + 0x08 = 0x1008  # arr[2]
rsp + 0x0c = 0x100c  # arr[3]
rsp + 0x10 = 0x1010  # arr[4]
rsp + 0x14 = 0x1014  # arr[5] ← 第六个数字
rsp + 0x18 = 0x1018  # arr[6]（不存在，但作为边界）← rbp指向这里
```

## **循环过程追踪：**

| 循环次数 | rbx值 | 与rbp比较 | 动作 |
|---------|-------|----------|------|
| 初始 | 0x1004 | != 0x1018 | 开始循环 |
| 第1次后 | 0x1008 | != 0x1018 | 继续 |
| 第2次后 | 0x100c | != 0x1018 | 继续 |
| 第3次后 | 0x1010 | != 0x1018 | 继续 |
| 第4次后 | 0x1014 | != 0x1018 | 继续 |
| 第5次后 | 0x1018 | == 0x1018 | 循环结束 |

**循环执行了5次**，对应检查第2到第6个数字是否符合条件。

## **为什么不是用 `rsp+0x14` 作为边界？**
```assembly
# 如果用 rsp+0x14 作为边界：
lea 0x4(%rsp), %rbx    # rbx = 0x1004
lea 0x14(%rsp), %rbp   # rbp = 0x1014（指向第六个数字）

# 循环检查：
# 当 rbx = 0x1014（指向第六个数字）时：
#   执行循环体检查第五和第六个数字
#   add $0x4,%rbx → rbx = 0x1018
#   cmp %rbp,%rbx → 0x1018 != 0x1014，会多循环一次！
```

所以必须用**之后**的地址作为边界，才能确保精确的循环次数。

## **在 gdb 中验证：**
```bash
(gdb) break phase_2
(gdb) run
输入：1 2 4 8 16 32
(gdb) info registers rsp   # 假设得到 0x7fffffffea20
(gdb) break *0x400f35      # 在 lea 0x18(%rsp),%rbp 后
(gdb) continue
(gdb) info registers rbp   # 应该显示 0x7fffffffea38
(gdb) print 0x7fffffffea38 - 0x7fffffffea20  # 差值为24（0x18）
```

## **通用规则：**
- 对于N个元素的数组，每个元素大小S
- 数组占据空间：N × S
- 结束边界地址：起始地址 + (N × S)
- 这样循环可以精确遍历所有元素

理解了这一点，你在分析其他phase的数组或循环时就能快速识别边界条件了！

## jne

## **`jne` 指令详解**

### **1. 基本定义**
`jne` = **Jump if Not Equal**（不相等时跳转）
- 另一种写法：`jnz` (Jump if Non-Zero)，两者完全等价
- 根据 **ZF（零标志）** 来决定是否跳转
- 条件：**当 ZF = 0 时跳转**，ZF = 1 时不跳转（继续执行下一条指令）

### **2. 工作原理**
```assembly
cmp %rax, %rbx   # 比较 rax 和 rbx
jne 标签         # 如果不相等，跳转到标签处
```
- 如果 `rax != rbx`，则 `rax - rbx ≠ 0` → ZF = 0 → 跳转
- 如果 `rax == rbx`，则 `rax - rbx = 0` → ZF = 1 → 不跳转

## **在 phase_2 中的具体应用：**

### **示例1：检查第一个数字**
```assembly
cmpl $0x1, (%rsp)    # 比较第一个数字和1
je   0x400f30        # 如果相等（等于1），跳转到0x400f30
call 0x40143a        # 否则引爆炸弹（不跳转就执行这行）
```
这里用 `je`（相等跳转），如果第一个数字不是1，就执行 `explode_bomb`

### **示例2：循环中的条件检查**
```assembly
cmp %eax, (%rbx)    # 比较当前数字(rbx)和前一个数字的2倍(eax)
je   0x400f25       # 如果相等，跳转到循环继续处
call 0x40143a       # 否则引爆炸弹
```

### **示例3：循环终止条件**
```assembly
cmp %rbp, %rbx      # 比较当前指针(rbx)与结束地址(rbp)
jne  0x400f17       # 如果不相等（没到末尾），跳转回循环开始
# 如果相等（到达末尾），继续执行循环后的代码
```

## **条件跳转指令家族：**

| 指令 | 含义 | 条件 | 检查的标志位 |
|------|------|------|------------|
| `je` / `jz` | 相等/为零 | ZF=1 | 零标志 |
| `jne` / `jnz` | 不相等/非零 | ZF=0 | 零标志 |
| `jg` | 大于（有符号） | ZF=0且SF=OF | ZF、SF、OF |
| `jge` | 大于等于（有符号） | SF=OF | SF、OF |
| `jl` | 小于（有符号） | SF≠OF | SF、OF |
| `jle` | 小于等于（有符号） | ZF=1或SF≠OF | ZF、SF、OF |
| `ja` | 高于（无符号） | CF=0且ZF=0 | CF、ZF |
| `jb` | 低于（无符号） | CF=1 | CF |

## **`jne` 在循环中的典型模式：**

### **模式1：do-while 风格**
```assembly
循环开始:
    # 循环体代码
    # ...
    cmp 条件        # 设置标志位
    jne 循环开始    # 条件成立时继续循环
```

### **模式2：while 风格**
```assembly
    jmp 条件检查
循环体:
    # 循环体代码
条件检查:
    cmp 条件
    jne 循环体      # 条件成立时跳回循环体
```

## **在 phase_2 中的完整循环结构：**

```assembly
# 循环初始化
lea 0x4(%rsp), %rbx    # rbx = 第二个数字地址
lea 0x18(%rsp), %rbp   # rbp = 结束地址

jmp 0x400f17           # 跳转到循环体开始

# 循环体开始 (0x400f17)
mov -0x4(%rbx), %eax   # eax = 前一个数字
add %eax, %eax         # eax *= 2
cmp %eax, (%rbx)       # 比较当前数字是否等于前一个数字的2倍
je 0x400f25            # 如果相等，继续执行
call explode_bomb      # 否则爆炸

# 循环继续 (0x400f25)
add $0x4, %rbx         # 移动到下一个数字
cmp %rbp, %rbx         # 检查是否到达末尾
jne 0x400f17           # 如果没到末尾，继续循环
# 到达末尾，循环结束
```

## **调试技巧：**
```bash
(gdb) break *0x400f2c       # 在 jne 指令处设断点
(gdb) run
(gdb) info registers eflags # 查看标志位，特别是ZF
(gdb) stepi                 # 执行jne，观察是否跳转
(gdb) info program          # 查看程序计数器位置
```

## **记忆口诀：**
- **`je`** = "相等跳转" → ZF=1 (Zero Flag set)
- **`jne`** = "不相等跳转" → ZF=0 (Zero Flag clear)
- 可以把 `jne` 理解为 "Jump if cmp result is **N**ot **E**qual"

理解了 `jne` 后，你就掌握了条件执行的核心机制。Bomb Lab 中大量使用这类跳转指令来实现条件判断和循环控制。


## jg

`jg` 是 **条件跳转指令**，表示 **"Jump if Greater"**（大于时跳转），用于**有符号数**的比较。

## **基本定义**

### **条件触发：**
`jg` 在以下条件同时满足时跳转：
- **ZF = 0**（结果不为零）
- **SF = OF**（符号标志等于溢出标志）

### **语法：**
```assembly
cmp 操作数1, 操作数2   # 计算 操作数2 - 操作数1
jg 标签               # 如果 操作数2 > 操作数1（有符号比较），跳转到标签
```

## **工作原理示例：**

### **示例1：简单比较**
```assembly
mov $5, %rax
mov $3, %rbx
cmp %rax, %rbx   # 比较：rbx(3) - rax(5) = -2
jg greater_label # 不会跳转，因为3不大于5
```

### **示例2：实际跳转**
```assembly
mov $-10, %rax
mov $-5, %rbx
cmp %rax, %rbx   # 比较：rbx(-5) - rax(-10) = 5
jg greater_label # 会跳转，因为-5 > -10
```

## **与其他条件跳转的对比：**

### **有符号数比较：**
| 指令 | 含义 | 条件 | 说明 |
|------|------|------|------|
| `jg` | 大于 | ZF=0 且 SF=OF | 严格大于 |
| `jge` | 大于等于 | SF=OF | 大于或等于 |
| `jl` | 小于 | SF≠OF | 严格小于 |
| `jle` | 小于等于 | ZF=1 或 SF≠OF | 小于或等于 |

### **无符号数比较：**
| 指令 | 含义 | 条件 | 说明 |
|------|------|------|------|
| `ja` | 高于 | CF=0 且 ZF=0 | 无符号大于 |
| `jae` | 高于等于 | CF=0 | 无符号大于等于 |
| `jb` | 低于 | CF=1 | 无符号小于 |
| `jbe` | 低于等于 | CF=1 或 ZF=1 | 无符号小于等于 |

## **关键区别：`jg` vs `ja`**

### **`jg`（有符号大于）：**
```assembly
# 有符号数：-5 < 3
mov $-5, %rax    # rax = -5
mov $3, %rbx     # rbx = 3
cmp %rax, %rbx   # rbx(3) - rax(-5) = 8
jg signed_greater # 会跳转！因为3 > -5
```

### **`ja`（无符号高于）：**
```assembly
# 无符号数：0xFFFFFFFF < 3？不！
mov $0xFFFFFFFF, %rax  # rax = 4294967295（无符号）
mov $3, %rbx           # rbx = 3
cmp %rax, %rbx         # rbx(3) - rax(大数) = 负数（会设置CF）
ja unsigned_above      # 不会跳转！因为3 < 4294967295
```

## **在 Bomb Lab 中的常见应用：**

### **应用1：范围检查**
```assembly
# 检查输入是否在某个范围内
cmpl $0x0, (%rsp)      # 比较输入和0
jl   too_small         # 如果小于0，错误
cmpl $0x63, (%rsp)     # 比较输入和99
jg   too_big           # 如果大于99，错误
```

### **应用2：循环控制**
```assembly
# 递减计数器循环
mov $0x5, %ecx         # 循环5次
loop_start:
    # ... 循环体 ...
    dec %ecx           # ecx--
    cmp $0, %ecx
    jg  loop_start     # 如果ecx > 0，继续循环
```

### **应用3：分支选择**
```assembly
# 根据输入值选择不同路径
mov (%rsp), %eax       # 读取输入
cmp $0x2, %eax         # 与2比较
jg  case_greater       # 如果输入>2，跳转
je  case_equal         # 如果输入=2，跳转
# 否则输入<2，继续执行
```

## **调试技巧：**
```bash
# 在jg指令处设置断点
(gdb) break *0x400fxx

# 运行到断点处
(gdb) run

# 查看比较前的寄存器值
(gdb) info registers rax rbx

# 查看标志位状态
(gdb) info registers eflags
# 或
(gdb) p $eflags

# 单步执行并观察是否跳转
(gdb) stepi
```

## **标志位状态分析：**
```bash
(gdb) p/t $eflags  # 以二进制显示eflags
# 关注这些位：
# ZF（零标志）：第6位
# SF（符号标志）：第7位  
# OF（溢出标志）：第11位

# 示例：如果比较结果是正数且没有溢出
# ZF=0, SF=0, OF=0 → SF=OF → jg跳转
```

## **记忆技巧：**
1. **`jg`** = Jump if Greater（有符号大于）
2. **`ja`** = Jump if Above（无符号高于）
3. **`g` 代表有符号，`a` 代表无符号**
4. 可以这样想：`g`reater 用于有符号数，`a`bove 用于无符号数

## **实际案例：**
在 phase_1 或 phase_2 中，你可能看到这样的代码：
```assembly
# 检查输入数量
call read_six_numbers
cmp $0x5, %eax      # 检查是否读取了至少6个？注意：eax返回成功读取的数量
jg   enough_numbers # 如果eax > 5（即>=6），继续
call explode_bomb   # 否则爆炸
```

**理解 `jg` 对于分析 Bomb Lab 中的条件分支至关重要！** 后续的 phase 会大量使用各种条件跳转指令。