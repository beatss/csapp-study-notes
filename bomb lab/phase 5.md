## phase 5
```
      0x0000000000401062 <+0>:     push   %rbx
   0x0000000000401063 <+1>:     sub    $0x20,%rsp
   0x0000000000401067 <+5>:     mov    %rdi,%rbx
   0x000000000040106a <+8>:     mov    %fs:0x28,%rax
   0x0000000000401073 <+17>:    mov    %rax,0x18(%rsp)
   0x0000000000401078 <+22>:    xor    %eax,%eax
   0x000000000040107a <+24>:    call   0x40131b <string_length>
   0x000000000040107f <+29>:    cmp    $0x6,%eax
   0x0000000000401082 <+32>:    je     0x4010d2 <phase_5+112>
   0x0000000000401084 <+34>:    call   0x40143a <explode_bomb>
   0x0000000000401089 <+39>:    jmp    0x4010d2 <phase_5+112>
   0x000000000040108b <+41>:    movzbl (%rbx,%rax,1),%ecx
   0x000000000040108f <+45>:    mov    %cl,(%rsp)
   0x0000000000401092 <+48>:    mov    (%rsp),%rdx
   0x0000000000401096 <+52>:    and    $0xf,%edx
   0x0000000000401099 <+55>:    movzbl 0x4024b0(%rdx),%edx
   0x00000000004010a0 <+62>:    mov    %dl,0x10(%rsp,%rax,1)
   0x00000000004010a4 <+66>:    add    $0x1,%rax
   0x00000000004010a8 <+70>:    cmp    $0x6,%rax
   0x00000000004010ac <+74>:    jne    0x40108b <phase_5+41>
   0x00000000004010ae <+76>:    movb   $0x0,0x16(%rsp)
   0x00000000004010b3 <+81>:    mov    $0x40245e,%esi
   0x00000000004010b8 <+86>:    lea    0x10(%rsp),%rdi
   0x00000000004010bd <+91>:    call   0x401338 <strings_not_equal>
   0x00000000004010c2 <+96>:    test   %eax,%eax
   0x00000000004010c4 <+98>:    je     0x4010d9 <phase_5+119>
   0x00000000004010c6 <+100>:   call   0x40143a <explode_bomb>
   0x00000000004010cb <+105>:   nopl   0x0(%rax,%rax,1)
   0x00000000004010d0 <+110>:   jmp    0x4010d9 <phase_5+119>
   0x00000000004010d2 <+112>:   mov    $0x0,%eax
   0x00000000004010d7 <+117>:   jmp    0x40108b <phase_5+41>
   0x00000000004010d9 <+119>:   mov    0x18(%rsp),%rax
   0x00000000004010de <+124>:   xor    %fs:0x28,%rax
   0x00000000004010e7 <+133>:   je     0x4010ee <phase_5+140>
   0x00000000004010e9 <+135>:   call   0x400b30 <__stack_chk_fail@plt>
   0x00000000004010ee <+140>:   add    $0x20,%rsp
   0x00000000004010f2 <+144>:   pop    %rbx
   0x00000000004010f3 <+145>:   ret
``
我来详细解析这个 Phase 5 的汇编代码。这是一个经典的 **"查表转换"** 谜题。

## 整体流程
这个 phase 要求输入一个长度为6的字符串，然后：
1. 取每个字符的低4位作为索引
2. 从一个16个字符的表中查找对应的字符
3. 组成一个新的6字符字符串
4. 与目标字符串比较

## 详细解析

### 1. 函数开场
```assembly
push   %rbx              ; 保存rbx（调用者保存寄存器）
sub    $0x20,%rsp        ; 分配32字节栈空间
mov    %rdi,%rbx         ; rdi是输入字符串指针，保存到rbx
```

### 2. 栈金丝雀保护
```assembly
mov    %fs:0x28,%rax     ; 获取栈保护值
mov    %rax,0x18(%rsp)   ; 存到栈上(rsp+0x18)位置
xor    %eax,%eax         ; 清空eax（同时作为零扩展，将rax高32位清零）
```
- `xor %eax,%eax`：这是将 `eax`（也就是 `rax` 的低32位）清零的标准方法。由于操作数是32位，会自动将 `rax` 的高32位也清零。这比 `mov $0, %rax` 更高效（指令更短）。

### 3. 检查字符串长度
```assembly
call   0x40131b <string_length>  ; 计算输入字符串长度
cmp    $0x6,%eax                 ; 长度必须为6
je     0x4010d2 <phase_5+112>    ; 等于6则跳转到初始化部分
call   0x40143a <explode_bomb>   ; 否则爆炸
jmp    0x4010d2 <phase_5+112>    ; 不必要的跳转（爆炸后不会执行到这里）
```

### 4. 初始化循环计数器
```assembly
0x4010d2 <+112>: mov    $0x0,%eax    ; eax = 0（循环计数器）
0x4010d7 <+117>: jmp    0x40108b <phase_5+41>  ; 跳转到循环开始
```

### 5. **核心循环**（+41到+74）
```assembly
0x40108b <+41>: movzbl (%rbx,%rax,1),%ecx  ; 读取输入字符串的第rax个字符到ecx
0x40108f <+45>: mov    %cl,(%rsp)          ; 将字符的低8位存到栈顶
0x401092 <+48>: mov    (%rsp),%rdx         ; 重新读取到rdx（64位）
0x401096 <+52>: and    $0xf,%edx           ; 取字符的低4位（0-15）
0x401099 <+55>: movzbl 0x4024b0(%rdx),%edx ; 查表：从0x4024b0 + 索引 处读取字符
0x4010a0 <+62>: mov    %dl,0x10(%rsp,%rax,1) ; 存到栈上rsp+0x10+rax位置
0x4010a4 <+66>: add    $0x1,%rax           ; 计数器加1
0x4010a8 <+70>: cmp    $0x6,%rax           ; 比较是否处理完6个字符
0x4010ac <+74>: jne    0x40108b <phase_5+41> ; 未完成则继续循环
```

**循环逻辑**：
```
for (rax = 0; rax < 6; rax++) {
    char c = input[rax];           // movzbl (%rbx,%rax,1),%ecx
    int index = c & 0xf;           // and $0xf,%edx
    char table_char = table[index]; // movzbl 0x4024b0(%rdx),%edx
    output[rax] = table_char;      // mov %dl,0x10(%rsp,%rax,1)
}
```

### 6. 构造新字符串
```assembly
0x4010ae <+76>: movb   $0x0,0x16(%rsp)      ; 在新字符串末尾添加'\0'
```
- 新字符串位置：`rsp+0x10` 到 `rsp+0x15`（6个字节）
- `rsp+0x16` 添加空字符作为字符串结束符

### 7. 字符串比较
```assembly
0x4010b3 <+81>: mov    $0x40245e,%esi        ; esi = 目标字符串地址
0x4010b8 <+86>: lea    0x10(%rsp),%rdi       ; rdi = 新字符串地址（栈上）
0x4010bd <+91>: call   0x401338 <strings_not_equal>
0x4010c2 <+96>: test   %eax,%eax
0x4010c4 <+98>: je     0x4010d9 <phase_5+119>  ; 相等则跳转到结尾
0x4010c6 <+100>: call   0x40143a <explode_bomb>  ; 否则爆炸
```

### 8. **nopl 指令**
```assembly
0x4010cb <+105>: nopl   0x0(%rax,%rax,1)
```
- **nopl**：No Operation Long，空操作指令
- **作用**：
  1. **代码对齐**：使后续代码地址对齐到特定边界（通常是16字节），提高CPU取指效率
  2. **占位**：保持代码布局，方便后续修改
  3. **无实际功能**，只是让CPU空转一个周期
- 格式 `0x0(%rax,%rax,1)` 是一个无效的寻址方式，但nopl忽略它

### 9. 函数返回
```assembly
0x4010d9 <+119>: mov    0x18(%rsp),%rax      ; 取出保存的栈金丝雀值
0x4010de <+124>: xor    %fs:0x28,%rax        ; 与原始值比较
0x4010e7 <+133>: je     0x4010ee <phase_5+140>  ; 相等则跳转（栈未破坏）
0x4010e9 <+135>: call   0x400b30 <__stack_chk_fail@plt>  ; 否则报告栈破坏
0x4010ee <+140>: add    $0x20,%rsp           ; 恢复栈指针
0x4010f2 <+144>: pop    %rbx                 ; 恢复rbx
0x4010f3 <+145>: ret                         ; 返回
```

## 关键内存地址

### 1. 查表地址：`0x4024b0`
使用 gdb 查看：
```bash
(gdb) x /16c 0x4024b0
```
你会看到16个字符的表，例如：
```
0x4024b0:  'm' 'a' 'd' 'u' 'i' 'e' 'r' 's'
0x4024b8:  'n' 'f' 'o' 't' 'v' 'b' 'y' 'l'
```
索引0-15分别对应这些字符。

### 2. 目标字符串地址：`0x40245e`
```bash
(gdb) x /s 0x40245e
```
通常结果是类似 `"flyers"` 这样的字符串。

## 求解过程

假设目标字符串是 `"flyers"`：
1. 在表中找到每个字符的位置：
   - 'f' 在表中位置（索引）是多少？
   - 'l' 在表中位置是多少？
   - 'y' 在表中位置是多少？
   - 'e' 在表中位置是多少？
   - 'r' 在表中位置是多少？
   - 's' 在表中位置是多少？

2. 这些索引值（0-15）就是输入字符需要的低4位

3. 构造输入字符：
   - 字符的低4位 = 对应索引
   - 高4位可以是任意值（通常选择可打印字符，如大写字母、数字等）

## 示例

如果表是：`"maduiersnfotvbyl"`
- 'f' 在索引9
- 'l' 在索引15
- 'y' 在索引14
- 'e' 在索引5
- 'r' 在索引6
- 's' 在索引7

那么输入字符的低4位应该是：9, 15, 14, 5, 6, 7

对应的ASCII字符（一种可能）：
- 9 → '9' (0x39 = 0011 1001，低4位1001=9)
- 15 → '?' (0x3F = 0011 1111，低4位1111=15)
- 14 → '>' (0x3E = 0011 1110，低4位1110=14)
- 5 → '%' (0x25 = 0010 0101，低4位0101=5)
- 6 → '&' (0x26 = 0010 0110，低4位0110=6)
- 7 → ''' (0x27 = 0010 0111，低4位0111=7)

所以输入可能是：`"9?>%&'"`（需要实际检查）

## 总结
Phase 5 是一个查表转换谜题，通过输入字符的低4位作为索引，从表中查找字符，生成新字符串后与目标比较。你需要：
1. 查看表的内容（0x4024b0）
2. 查看目标字符串（0x40245e）
3. 反推出输入字符的低4位
4. 构造可打印的输入字符串