## phase 3
```
 解析一下phase 3的汇编
     0x0000000000400f43 <+0>:     sub    $0x18,%rsp
   0x0000000000400f47 <+4>:     lea    0xc(%rsp),%rcx
   0x0000000000400f4c <+9>:     lea    0x8(%rsp),%rdx
   0x0000000000400f51 <+14>:    mov    $0x4025cf,%esi
   0x0000000000400f56 <+19>:    mov    $0x0,%eax
   0x0000000000400f5b <+24>:    call   0x400bf0 <__isoc99_sscanf@plt>
   0x0000000000400f60 <+29>:    cmp    $0x1,%eax
   0x0000000000400f63 <+32>:    jg     0x400f6a <phase_3+39>
   0x0000000000400f65 <+34>:    call   0x40143a <explode_bomb>
   0x0000000000400f6a <+39>:    cmpl   $0x7,0x8(%rsp)
   0x0000000000400f6f <+44>:    ja     0x400fad <phase_3+106>
   0x0000000000400f71 <+46>:    mov    0x8(%rsp),%eax
   0x0000000000400f75 <+50>:    jmp    *0x402470(,%rax,8)
   0x0000000000400f7c <+57>:    mov    $0xcf,%eax
   0x0000000000400f81 <+62>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f83 <+64>:    mov    $0x2c3,%eax
   0x0000000000400f88 <+69>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f8a <+71>:    mov    $0x100,%eax
   0x0000000000400f8f <+76>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f91 <+78>:    mov    $0x185,%eax
   0x0000000000400f96 <+83>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f98 <+85>:    mov    $0xce,%eax
   0x0000000000400f9d <+90>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f9f <+92>:    mov    $0x2aa,%eax
   0x0000000000400fa4 <+97>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400fa6 <+99>:    mov    $0x147,%eax
   0x0000000000400fab <+104>:   jmp    0x400fbe <phase_3+123>
   0x0000000000400fad <+106>:   call   0x40143a <explode_bomb>
   0x0000000000400fb2 <+111>:   mov    $0x0,%eax
   0x0000000000400fb7 <+116>:   jmp    0x400fbe <phase_3+123>
   0x0000000000400fb9 <+118>:   mov    $0x137,%eax
   0x0000000000400fbe <+123>:   cmp    0xc(%rsp),%eax
   0x0000000000400fc2 <+127>:   je     0x400fc9 <phase_3+134>
   0x0000000000400fc4 <+129>:   call   0x40143a <explode_bomb>
   0x0000000000400fc9 <+134>:   add    $0x18,%rsp
   0x0000000000400fcd <+138>:   ret
   ```
   
  这是 **phase_3** 的汇编代码，这是一个典型的 **switch-case 结构**（跳转表）。让我详细解析：

## **函数流程分析：**

### **第1部分：读取输入**
```
<+0> ~ <+24>:  分配栈空间，准备sscanf参数
<+14>:         mov $0x4025cf,%esi  # 格式字符串地址
<+24>:         call sscanf
```
- 查看格式字符串：`x/s 0x4025cf`（通常是 `"%d %d"` 或 `"%d %c %d"`）
- 读取两个输入：第一个存在 `0x8(%rsp)`，第二个存在 `0xc(%rsp)`

### **第2部分：验证输入数量**
```
<+29>:    cmp $0x1,%eax    # 比较sscanf返回值
<+32>:    jg  <phase_3+39> # 如果>1（至少读取2个值），继续
<+34>:    call explode_bomb # 否则爆炸
```

### **第3部分：检查第一个输入范围**
```
<+39>:    cmpl $0x7,0x8(%rsp)  # 比较第一个输入和7
<+44>:    ja   0x400fad        # 如果>7（无符号比较），爆炸
```
- **关键条件1**：第一个输入必须在 **0-7** 范围内（`ja`是无符号跳转）

### **第4部分：跳转表（switch-case核心）**
```
<+46>:    mov 0x8(%rsp),%eax    # eax = 第一个输入
<+50>:    jmp *0x402470(,%rax,8) # 间接跳转
```
- **跳转表地址**：`0x402470`
- **跳转表项大小**：8字节
- **计算公式**：跳转地址 = `[0x402470 + 第一个输入 × 8]`

### **第5部分：case分支（每个分支给eax赋值）**
从 `<+57>` 到 `<+104>` 是各个case：
```
0:  mov $0xcf,%eax     (207)   → <+57>
1:  mov $0x2c3,%eax    (707)   → <+64>
2:  mov $0x100,%eax    (256)   → <+71>
3:  mov $0x185,%eax    (389)   → <+78>
4:  mov $0xce,%eax     (206)   → <+85>
5:  mov $0x2aa,%eax    (682)   → <+92>
6:  mov $0x147,%eax    (327)   → <+99>
7:  mov $0x137,%eax    (311)   → <+118>（注意这个在后面）
```

### **第6部分：比较第二个输入**
```
<+123>:   cmp 0xc(%rsp),%eax  # 比较eax和第二个输入
<+127>:   je  <phase_3+134>   # 如果相等，通过
<+129>:   call explode_bomb   # 否则爆炸
```
- **关键条件2**：第二个输入必须等于case中给eax赋的值

## **完整的switch-case映射：**

| 第一个输入 | 跳转地址 | eax值（十进制） | 第二个输入必须等于 |
|-----------|----------|----------------|-------------------|
| 0 | 0x400f7c | 0xcf = 207 | 207 |
| 1 | 0x400f83 | 0x2c3 = 707 | 707 |
| 2 | 0x400f8a | 0x100 = 256 | 256 |
| 3 | 0x400f91 | 0x185 = 389 | 389 |
| 4 | 0x400f98 | 0xce = 206 | 206 |
| 5 | 0x400f9f | 0x2aa = 682 | 682 |
| 6 | 0x400fa6 | 0x147 = 327 | 327 |
| 7 | 0x400fb9 | 0x137 = 311 | 311 |

## **解题步骤：**

### **1. 查看格式字符串**
```bash
(gdb) x/s 0x4025cf
```
可能显示：`"%d %d"` 或 `"%d %c %d"` 等

### **2. 查看跳转表**
```bash
(gdb) x/8gx 0x402470
```
应该看到8个地址，对应上面的跳转目标。

### **3. 选择任意一对有效输入**
例如：`0 207` 或 `1 707` 等

### **4. 测试验证**
```bash
# 创建答案文件
echo "phase1答案" > solution.txt
echo "phase2答案" >> solution.txt
echo "0 207" >> solution.txt  # phase3答案

./bomb solution.txt
```

## **在gdb中调试：**
```bash
(gdb) break phase_3
(gdb) run
# 输入：0 207
(gdb) stepi  # 单步执行
# 观察跳转到哪个case
(gdb) info registers eax  # 查看eax的值
```

## **注意事项：**
1. **第一个输入必须是0-7的整数**
2. **第二个输入必须与对应的case值完全相等**
3. **有8种可能的正确组合**，任意一种都能通过
4. 如果第一个输入>7，会直接爆炸（`ja`指令）

## **常见的phase3答案：**
- `0 207`
- `1 707` 
- `2 256`
- `3 389`
- `4 206`
- `5 682`
- `6 327`
- `7 311`

**phase_3的关键是理解跳转表（switch-case）的实现方式。** 现在你可以选择任意一组有效输入来通过这一关！需要我帮你分析跳转表的具体内容吗？

### jmp *0x402470(,%rax,8) # 间接跳转 0x402470
**这是一个非常好的问题！** 这涉及到 x86 汇编中 **间接跳转** 的语法。让我详细解释：

## **语法解析：**

### **1. `*` 符号的含义**
在 AT&T 汇编语法中：
- **有 `*`**：表示 **间接跳转/调用**（跳转到寄存器或内存中存储的地址）
- **无 `*`**：表示 **直接跳转/调用**（跳转到固定的代码地址）

### **2. 对比示例：**
```assembly
# 直接跳转：跳转到固定地址 0x400fbe
jmp 0x400fbe

# 间接跳转：跳转到 rax 寄存器中存储的地址
jmp *%rax

# 间接跳转：跳转到内存地址 0x402470 处存储的地址
jmp *0x402470

# 间接跳转（带偏移）：跳转到 [0x402470 + rax*8] 处存储的地址
jmp *0x402470(,%rax,8)
```

## **具体到 `jmp *0x402470(,%rax,8)`：**

### **计算过程：**
1. **计算内存地址**：`地址 = 0x402470 + %rax × 8`
2. **读取该地址的内容**：从计算出的地址处读取 8 字节（64位地址）
3. **跳转到读取的地址**：CPU 跳转到这个地址执行

### **可视化流程：**
```
假设第一个输入 = 2（存储在 rax 中）
1. 计算：0x402470 + 2 × 8 = 0x402480
2. 读取地址 0x402480 处的8个字节：比如得到 0x400f8a
3. 跳转到 0x400f8a 执行（这就是 case 2）
```

## **为什么需要 `*`？**

### **内存 vs 立即数：**
```assembly
# 错误：这会被解释为跳转到地址 0x402470
jmp 0x402470          # 直接跳转到代码地址 0x402470

# 正确：跳转到地址 [0x402470] 处存储的值
jmp *0x402470         # 间接跳转，从内存读取跳转目标
```

### **类比指针：**
```c
// C语言类比
int *jump_table[8] = {&case0, &case1, &case2, ...};

// 直接跳转（相当于 jmp 0x400f8a）
goto case2;

// 间接跳转（相当于 jmp *0x402470(,%rax,8)）
goto *jump_table[input];
```

## **查看跳转表内容：**

### **在 gdb 中：**
```bash
# 查看跳转表（8个64位地址）
(gdb) x/8gx 0x402470

# 示例输出：
# 0x402470: 0x0000000000400f7c  0x0000000000400f83
# 0x402480: 0x0000000000400f8a  0x0000000000400f91
# 0x402490: 0x0000000000400f98  0x0000000000400f9f
# 0x4024a0: 0x0000000000400fa6  0x0000000000400fb9
```

### **反汇编查看：**
```bash
# 查看每个跳转目标处的代码
(gdb) disas 0x400f7c,0x400f84
```

## **跳转表的内存布局：**
```
地址          存储的值（64位地址）    对应的case
0x402470     0x0000000000400f7c     case 0
0x402478     0x0000000000400f83     case 1
0x402480     0x0000000000400f8a     case 2
0x402488     0x0000000000400f91     case 3
0x402490     0x0000000000400f98     case 4
0x402498     0x0000000000400f9f     case 5
0x4024a0     0x0000000000400fa6     case 6
0x4024a8     0x0000000000400fb9     case 7
```

## **实际执行示例：**

假设输入 `2`（第一个数字）：
```assembly
# 1. mov 0x8(%rsp),%eax    # eax = 2
# 2. jmp *0x402470(,%rax,8) # 计算：0x402470 + 2×8 = 0x402480
# 3. 读取 0x402480 处的值：0x400f8a
# 4. 跳转到 0x400f8a 执行
# 5. 在 0x400f8a: mov $0x100,%eax  # eax = 256
```

## **为什么每个表项是8字节？**
- 64位系统，地址是64位（8字节）
- 所以跳转表每个条目需要8字节来存储目标地址

## **调试技巧：**
```bash
# 1. 设置断点在间接跳转前
(gdb) break *0x400f75
(gdb) run
输入：2 256

# 2. 查看寄存器
(gdb) info registers rax  # 应该显示2

# 3. 单步执行
(gdb) stepi

# 4. 查看跳转目标
(gdb) info program        # 显示当前执行地址，应该是0x400f8a
```

## **关键点总结：**
1. **`*`** 表示间接跳转（通过内存中的地址跳转）
2. **`0x402470(,%rax,8)`** 是内存寻址表达式
3. 这实现了 **switch-case 的跳转表优化**
4. 编译器用这种方式高效处理多个分支

**理解了间接跳转，你就掌握了 switch-case 的实现原理！** 这在逆向工程中非常常见。

**不对！这是个常见的误解。让我澄清一下：**

## **寄存器大小和乘法含义：**

### **1. 寄存器大小**
- **%rax** 是 **64位** 寄存器，存储 **8字节** 内容
- **%eax** 是 **32位** 寄存器，存储 **4字节** 内容（rax的低32位）
- **%ax** 是 **16位** 寄存器，存储 **2字节** 内容
- **%al** 是 **8位** 寄存器，存储 **1字节** 内容

### **2. `%rax × 8` 的含义**
```assembly
# 这个表达式出现在寻址模式中：
0x402470(,%rax,8)

# 意思是：rax寄存器中的值 × 8
# 不是：从rax地址开始读取8个字节！
```

## **正确的解释：**

### **计算过程：**
1. **获取 rax 的值**：假设 rax = 2（你输入的第一个数字）
2. **乘以比例因子**：2 × 8 = 16（十进制）= 0x10（十六进制）
3. **加上基址**：0x402470 + 0x10 = 0x402480
4. **读取该地址**：从内存地址 0x402480 处读取 **8字节**（一个64位地址）

### **可视化：**
```
rax 中的值：2（这是一个数字，不是地址）
计算：0x402470 + 2×8 = 0x402470 + 16 = 0x402480
访问：读取地址 0x402480 处的8个字节，假设是 0x0000000000400f8a
跳转：跳转到 0x400f8a 执行
```

## **与指针的类比：**

### **C语言对应代码：**
```c
// 跳转表：存储8个函数指针（64位系统，每个指针8字节）
void* jump_table[8] = {&case0, &case1, &case2, &case3, 
                       &case4, &case5, &case6, &case7};

// 获取用户输入
int index = 2;  // 存储在 rax 中

// 计算跳转地址：jump_table[index]
// 相当于：基地址 + index × sizeof(void*)
//        0x402470 + 2 × 8 = 0x402480
void* target = jump_table[index];

// 跳转
goto *target;
```

## **常见误解 vs 正确理解：**

| 误解 | 正确 |
|------|------|
| "从 rax 地址读取8字节" | **rax 存储的是索引值**，不是地址 |
| "rax × 8 表示8个字节" | 8是**比例因子**，不是字节数 |
| "读取 rax 寄存器内容" | 读取的是**计算出的内存地址**的内容 |

## **实际调试示例：**
```bash
# 假设输入第一个数字是3
(gdb) break phase_3
(gdb) run
输入：3 389

# 执行到 jmp 指令前
(gdb) info registers rax
rax            0x3                 3  # rax存储的是数字3

(gdb) print 0x402470 + 3*8
$1 = 0x402488  # 计算出的内存地址

(gdb) x/gx 0x402488
0x402488: 0x0000000000400f91  # 这里存储的是跳转目标

(gdb) disas 0x400f91
0x400f91: mov $0x185,%eax  # case 3的代码
```

## **关键点总结：**
1. **%rax 存储的是索引值**（0-7的数字），不是内存地址
2. **×8** 是因为每个跳转表项是8字节（64位地址）
3. **最终读取的是计算出的内存地址处的8个字节**
4. 这实现了 **数组索引访问**：`跳转表[索引]`

## **记忆技巧：**
- `(,%rax,8)` 类似于数组访问：`array[rax]`
- 比例因子 8 对应数组元素大小（8字节）
- rax 是数组索引，不是地址

**现在理解了吗？rax 存储的是你输入的数字（如0,1,2...），这个数字乘以8后作为偏移量，加上基址得到跳转表项的地址。**


### 比例因子
**比例因子不是固定的！** 它有四种可能的值：1、2、4、8。具体取决于数组元素的类型大小。

## **比例因子的四种取值：**

### **1. 比例因子=1（字节数组）**
```assembly
movb (%rax, %rbx, 1), %cl   # 读取一个字节
```
- **元素大小**：1字节
- **适用类型**：`char`、`unsigned char`、布尔数组
- **典型用途**：字符串处理、字节缓冲区

### **2. 比例因子=2（字数组）**
```assembly
movw (%rax, %rbx, 2), %cx   # 读取一个字（2字节）
```
- **元素大小**：2字节
- **适用类型**：`short`、`unsigned short`
- **典型用途**：16位音频数据、Unicode字符串（UTF-16）

### **3. 比例因子=4（双字数组）**
```assembly
movl (%rax, %rbx, 4), %ecx  # 读取一个双字（4字节）
```
- **元素大小**：4字节
- **适用类型**：`int`、`unsigned int`、`float`、32位指针
- **典型用途**：整数数组、浮点数组（最常见）

### **4. 比例因子=8（四字数组）**
```assembly
movq (%rax, %rbx, 8), %rcx  # 读取一个四字（8字节）
```
- **元素大小**：8字节
- **适用类型**：`long`、`double`、**64位指针**、`long long`
- **典型用途**：跳转表（如phase_3）、双精度浮点数组、大整数数组

## **在 phase_3 中为什么是8？**

### **原因分析：**
1. **64位系统**：内存地址是64位，需要8字节存储
2. **跳转表存储的是函数地址**：每个表项是一个64位地址
3. **验证**：用gdb查看相邻表项的地址差

```bash
(gdb) x/8gx 0x402470
0x402470: 0x0000000000400f7c  0x0000000000400f83
0x402480: 0x0000000000400f8a  0x0000000000400f91

# 计算地址差：
# 0x402478 - 0x402470 = 8 字节
# 0x402480 - 0x402478 = 8 字节
```

## **不同比例因子的实际例子：**

### **例子1：int数组（比例因子4）**
```c
// C代码
int arr[100];
arr[i] = 10;

// 对应汇编
# 假设arr基址在rax，索引i在rbx
movl $10, (%rax, %rbx, 4)
```

### **例子2：double数组（比例因子8）**
```c
// C代码
double arr[100];
arr[i] = 3.14;

// 对应汇编
# 假设arr基址在rax，索引i在rbx
movsd 3.14, (%rax, %rbx, 8)
```

### **例子3：char数组（比例因子1）**
```c
// C代码
char str[100];
str[i] = 'A';

// 对应汇编
# 假设str基址在rax，索引i在rbx
movb $65, (%rax, %rbx, 1)
```

## **如何确定比例因子？**

### **方法1：查看指令后缀**
```assembly
movb ...  # 字节 → 比例因子可能是1
movw ...  # 字 → 比例因子可能是2  
movl ...  # 双字 → 比例因子可能是4
movq ...  # 四字 → 比例因子可能是8
```

### **方法2：查看上下文**
```assembly
# phase_3 中，跳转目标都是64位地址
# 所以每个表项需要8字节存储
jmp *0x402470(,%rax,8)  # 比例因子8
```

### **方法3：调试验证**
```bash
# 查看相邻元素地址差
(gdb) x/2gx 0x402470  # 查看前两个表项
# 如果地址差为8 → 比例因子8
# 如果地址差为4 → 比例因子4
```

## **特殊比例因子情况：**

### **1. 结构体数组**
如果数组元素是结构体，比例因子就是结构体的大小：
```c
struct Point {
    int x;    // 4字节
    int y;    // 4字节
    double z; // 8字节
}; // 总共16字节

// 汇编访问 arr[i].x
movl (%rax, %rbx, 16), %ecx  # 比例因子16!
```

### **2. 多维度数组**
二维数组的计算更复杂，但比例因子仍是元素大小。

## **Bomb Lab 其他阶段的比例因子：**

### **phase_6**（可能涉及指针数组）：
```assembly
# 可能看到这样的代码
mov (%rax, %rbx, 8), %rcx  # 比例因子8，处理链表节点指针
```

### **phase_5**（可能涉及字符数组）：
```assembly
movzbl (%rax, %rbx, 1), %ecx  # 比例因子1，处理字符串
```

## **总结：**
1. **比例因子 = 数组元素的大小**
2. **常见值**：1、2、4、8，由元素类型决定
3. **phase_3中用8**：因为跳转表存储64位地址（8字节）
4. **不是固定值**：需要根据上下文分析

**现在你明白为什么phase_3的比例因子是8了吧？** 这是由64位系统上指针的大小决定的。

**这个问题非常好！** 这种间接跳转在实际编程中**非常常见**，是编译器优化的重要技术。让我详细解释：

## **实际编程中的应用场景：**

### **1. Switch-Case 语句（最典型的应用）**
```c
// C语言中的switch语句
int func(int x) {
    switch(x) {
        case 0: return 100;
        case 1: return 200;
        case 2: return 300;
        case 3: return 400;
        default: return -1;
    }
}
```
**编译器会生成：**
```assembly
# 跳转表
.section .rodata
jump_table:
    .quad case0
    .quad case1
    .quad case2
    .quad case3

.text
func:
    cmp $3, %edi
    ja   default_case
    jmp *jump_table(,%rdi,8)  # 间接跳转！
```

### **2. 虚函数表（C++多态）**
```cpp
class Animal {
public:
    virtual void speak() = 0;
};

class Dog : public Animal {
    void speak() override { cout << "Woof!" << endl; }
};

Animal* animal = new Dog();
animal->speak();  // 通过虚函数表间接调用
```
**底层实现：**
```assembly
# animal对象前8字节是虚函数表指针
mov (%rax), %rbx      # 读取虚函数表地址
mov (%rbx), %rcx      # 读取speak函数地址（表中第一项）
call *%rcx            # 间接调用
```

### **3. 函数指针数组（回调机制）**
```c
// 事件处理系统
typedef void (*EventHandler)(int);
EventHandler handlers[10];

handlers[event_type](event_data);  // 间接调用
```

### **4. 解释器和虚拟机**
```c
// 字节码解释器
void interpret(Bytecode* code) {
    void* jump_table[256] = { /* 256个操作码的处理函数 */ };
    
    while (1) {
        Bytecode op = *code++;
        // 间接跳转到对应的处理函数
        ((void (*)())jump_table[op])();
    }
}
```

### **5. 状态机**
```c
// 状态机实现
typedef void (*StateHandler)();
StateHandler states[5] = {idle_state, running_state, error_state};

int current_state = 0;
states[current_state]();  // 执行当前状态的处理函数
```

## **为什么要用跳转表？**

### **性能优势：**
- **O(1)时间复杂度**：直接计算跳转，无需逐个比较
- **避免分支预测失败**：现代CPU对分支预测很敏感，跳转表更可预测
- **代码紧凑**：特别适合case值密集的情况

### **对比 if-else 链：**
```c
// 低效方式
if (x == 0) { /* case 0 */ }
else if (x == 1) { /* case 1 */ }
else if (x == 2) { /* case 2 */ }
...
// 需要O(n)比较，分支预测容易失败

// 高效方式（编译器优化为跳转表）
switch(x) {
    case 0: ... break;
    case 1: ... break;
    case 2: ... break;
    ...
}
```

## **根据汇编推测的原始C代码：**

```c
void phase_3(char* input) {
    int x, y;
    
    // 读取两个整数
    if (sscanf(input, "%d %d", &x, &y) <= 1) {
        explode_bomb();
    }
    
    // 检查第一个数范围
    if ((unsigned)x > 7) {  // ja是无符号比较
        explode_bomb();
    }
    
    int result;
    switch(x) {  // 编译器优化为跳转表
        case 0: result = 0xcf; break;    // 207
        case 1: result = 0x2c3; break;   // 707
        case 2: result = 0x100; break;   // 256
        case 3: result = 0x185; break;   // 389
        case 4: result = 0xce; break;    // 206
        case 5: result = 0x2aa; break;   // 682
        case 6: result = 0x147; break;   // 327
        case 7: result = 0x137; break;   // 311
    }
    
    if (result != y) {
        explode_bomb();
    }
}
```

## **现实世界的例子：**

### **Linux内核中的使用：**
```c
// 系统调用分发（arch/x86/entry/entry_64.S）
call *sys_call_table(,%rax,8)  // 根据系统调用号跳转
```

### **JavaScript引擎（V8）的字节码解释器：**
```assembly
// 字节码处理分发
jmp *jumptable(,%rax,8)  // rax = 字节码操作码
```

### **网络协议处理：**
```c
// 根据协议类型分发处理
void (*handlers[256])(Packet*);
handlers[packet->type](packet);
```

### **GUI事件处理：**
```c
// Windows消息循环（简化版）
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, ...) {
    static const Handler handlers[] = {
        [WM_CREATE] = handle_create,
        [WM_PAINT] = handle_paint,
        [WM_CLOSE] = handle_close,
        // ...
    };
    
    if (msg < ARRAY_SIZE(handlers) && handlers[msg]) {
        return handlers[msg](hwnd, ...);
    }
    return DefWindowProc(hwnd, msg, ...);
}
```

## **调试和分析技巧：**

### **在gdb中查看跳转表：**
```bash
# 查看所有跳转表项
(gdb) x/8a 0x402470

# 反汇编每个跳转目标
(gdb) disas 0x400f7c, 0x400f84
```

### **识别跳转表模式：**
1. **基地址+索引×固定大小**的间接跳转
2. **索引范围检查**（如 `ja 0x400fad` 检查>7）
3. **多个分支代码块**，每个给寄存器赋不同值
4. **最终汇聚到同一位置**进行比较

## **性能考虑：**

### **何时使用跳转表？**
- **case值密集**：如0,1,2,3,4...
- **case数量多**（通常>4-5个）
- **执行频率高**，需要优化性能

### **何时不用跳转表？**
- **case值稀疏**：如1,100,1000（跳转表会很大）
- **case数量少**：直接用if-else更快
- **有副作用**：case中有复杂的变量声明等

## **总结：**
`0x402470(,%rax,8)` 这种间接跳转是**编译器优化的重要技术**，在现实编程中：
1. **Switch-case的典型实现**
2. **多态（虚函数）的基础**
3. **回调机制的核心**
4. **解释器/虚拟机的关键优化**
5. **系统调用分发的标准做法**

**理解了这种模式，你就能看懂很多高性能代码的实现原理！** 这也是为什么 Bomb Lab 要教这个——它确实是实际系统中广泛使用的技术。